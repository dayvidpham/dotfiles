# OpenClaw OpenBao Secrets Store Module
# Deploys OpenBao (open-source Vault fork) in a Podman container
# Stores secrets and provides OIDC-authenticated access for injectors
{ config
, pkgs
, lib ? pkgs.lib
, ...
}:
let
  cfg = config.CUSTOM.virtualisation.openclaw;
  openbaoCfg = cfg.zeroTrust.openbao;
  keycloakCfg = cfg.zeroTrust.keycloak;
  enabledInstances = lib.filterAttrs (n: v: v.enable) cfg.instances;

  inherit (lib)
    mkIf
    mkOption
    mkEnableOption
    types
    concatStringsSep
    ;

  # OpenBao server configuration
  openbaoConfig = pkgs.writeText "openbao-config.hcl" ''
    # OpenBao Server Configuration for OpenClaw
    # Generated by NixOS module

    storage "file" {
      path = "/vault/data"
    }

    listener "tcp" {
      address     = "0.0.0.0:8200"
      tls_disable = true  # Internal network only
    }

    # API address for clients
    api_addr = "http://openclaw-openbao:8200"

    # Cluster address (single node)
    cluster_addr = "http://openclaw-openbao:8201"

    # Disable mlock for container environment
    disable_mlock = true

    # UI for debugging (can be disabled in production)
    ui = ${if openbaoCfg.enableUI then "true" else "false"}

    # Telemetry for monitoring
    telemetry {
      disable_hostname = true
    }

    # Audit logging
    log_level = "info"
  '';

  # Policy for each injector instance - restricts access to only its secrets
  mkInstancePolicy = name: pkgs.writeText "openclaw-${name}-policy.hcl" ''
    # Policy for openclaw-injector-${name}
    # Only allows access to secrets for instance: ${name}

    # Read secrets for this instance
    path "secret/data/openclaw/${name}/*" {
      capabilities = ["read"]
    }

    # List secrets for this instance
    path "secret/metadata/openclaw/${name}/*" {
      capabilities = ["list"]
    }

    # No access to other instances' secrets
  '';

  openbaoImage = "quay.io/openbao/openbao:2.1";

in
{
  options.CUSTOM.virtualisation.openclaw.zeroTrust.openbao = {
    enable = mkEnableOption "OpenBao secrets store for zero-trust secrets";

    httpPort = mkOption {
      type = types.port;
      default = 8200;
      description = "HTTP API port for OpenBao (internal only)";
    };

    dataDir = mkOption {
      type = types.str;
      default = "/var/lib/openclaw/openbao";
      description = "Directory for OpenBao data";
    };

    enableUI = mkOption {
      type = types.bool;
      default = false;
      description = "Enable OpenBao web UI (for debugging only)";
    };

    auditLogPath = mkOption {
      type = types.str;
      default = "/var/log/openclaw/openbao-audit.log";
      description = "Path to OpenBao audit log";
    };

    # Root token is only used for initial setup
    # After setup, OIDC authentication is used
    rootTokenFile = mkOption {
      type = types.nullOr types.path;
      default = null;
      description = "Path to file containing initial root token (for setup only)";
    };

    unsealKeysDir = mkOption {
      type = types.str;
      default = "/var/lib/openclaw/openbao/unseal-keys";
      description = "Directory to store unseal keys (protected, root-only)";
    };
  };

  config = mkIf (cfg.enable && cfg.zeroTrust.enable && openbaoCfg.enable) {
    # Assertions
    assertions = [
      {
        assertion = keycloakCfg.enable;
        message = "OpenBao requires Keycloak for OIDC authentication. Enable CUSTOM.virtualisation.openclaw.zeroTrust.keycloak";
      }
    ];

    # Create data directories
    systemd.tmpfiles.rules = [
      "d ${openbaoCfg.dataDir} 0700 100 100 -"  # UID 100 = vault user in container
      "d ${openbaoCfg.dataDir}/data 0700 100 100 -"
      "d ${openbaoCfg.dataDir}/logs 0700 100 100 -"
      "d ${openbaoCfg.dataDir}/config 0700 100 100 -"
      "d ${openbaoCfg.unsealKeysDir} 0700 root root -"
      "d /var/log/openclaw 0750 root openclaw-bridge -"
    ];

    # OpenBao container
    systemd.services.podman-openclaw-openbao = {
      description = "OpenBao Secrets Store for OpenClaw";
      after = [
        "podman.service"
        "openclaw-secrets-network.service"
        "podman-openclaw-keycloak.service"
      ];
      requires = [
        "podman.service"
        "openclaw-secrets-network.service"
      ];
      wants = [ "podman-openclaw-keycloak.service" ];
      wantedBy = [ "multi-user.target" ];

      serviceConfig = {
        Type = "simple";
        Restart = "always";
        RestartSec = "10s";

        ExecStart = pkgs.writeShellScript "openclaw-openbao-start" ''
          set -euo pipefail

          # Copy config to container-accessible location
          cp ${openbaoConfig} ${openbaoCfg.dataDir}/config/openbao.hcl
          chmod 644 ${openbaoCfg.dataDir}/config/openbao.hcl
          chown 100:100 ${openbaoCfg.dataDir}/config/openbao.hcl

          exec ${pkgs.podman}/bin/podman run \
            --name openclaw-openbao \
            --replace \
            --network ${keycloakCfg.network.name} \
            --publish "127.0.0.1:${toString openbaoCfg.httpPort}:8200" \
            --volume "${openbaoCfg.dataDir}/data:/vault/data:rw" \
            --volume "${openbaoCfg.dataDir}/logs:/vault/logs:rw" \
            --volume "${openbaoCfg.dataDir}/config:/vault/config:ro" \
            --env "BAO_ADDR=http://127.0.0.1:8200" \
            --env "BAO_API_ADDR=http://openclaw-openbao:8200" \
            --cap-add IPC_LOCK \
            --health-cmd "bao status -format=json | grep -q '\"sealed\":false' || exit 1" \
            --health-interval 30s \
            --health-retries 3 \
            --security-opt "no-new-privileges:true" \
            ${openbaoImage} \
            server -config=/vault/config/openbao.hcl
        '';

        ExecStop = "${pkgs.podman}/bin/podman stop -t 30 openclaw-openbao";
        ExecStopPost = "${pkgs.podman}/bin/podman rm -f openclaw-openbao || true";
      };
    };

    # OpenBao initialization and configuration service
    # This initializes OpenBao, enables OIDC auth, and sets up policies
    systemd.services.openclaw-openbao-init = {
      description = "Initialize OpenBao and Configure OIDC Authentication";
      after = [
        "podman-openclaw-openbao.service"
        "openclaw-keycloak-init.service"
      ];
      requires = [ "podman-openclaw-openbao.service" ];
      wants = [ "openclaw-keycloak-init.service" ];
      wantedBy = [ "multi-user.target" ];

      path = [ pkgs.curl pkgs.jq pkgs.coreutils ];

      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;

        ExecStart = pkgs.writeShellScript "openclaw-openbao-init" ''
          set -euo pipefail

          OPENBAO_ADDR="http://127.0.0.1:${toString openbaoCfg.httpPort}"
          KEYCLOAK_URL="http://127.0.0.1:${toString keycloakCfg.httpPort}"
          UNSEAL_KEYS_DIR="${openbaoCfg.unsealKeysDir}"

          # Wait for OpenBao to be available
          echo "Waiting for OpenBao to be available..."
          for i in $(seq 1 30); do
            if curl -sf "$OPENBAO_ADDR/v1/sys/health" >/dev/null 2>&1; then
              echo "OpenBao is available"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "OpenBao failed to become available"
              exit 1
            fi
            sleep 2
          done

          # Check if already initialized
          INIT_STATUS=$(curl -sf "$OPENBAO_ADDR/v1/sys/init" | jq -r '.initialized')

          if [ "$INIT_STATUS" = "false" ]; then
            echo "Initializing OpenBao..."

            # Initialize with 5 key shares, 3 threshold
            INIT_RESPONSE=$(curl -sf -X PUT "$OPENBAO_ADDR/v1/sys/init" \
              -H "Content-Type: application/json" \
              -d '{"secret_shares": 5, "secret_threshold": 3}')

            # Save unseal keys and root token securely
            echo "$INIT_RESPONSE" | jq -r '.keys[]' > "$UNSEAL_KEYS_DIR/unseal-keys.txt"
            echo "$INIT_RESPONSE" | jq -r '.root_token' > "$UNSEAL_KEYS_DIR/root-token.txt"
            chmod 400 "$UNSEAL_KEYS_DIR/unseal-keys.txt" "$UNSEAL_KEYS_DIR/root-token.txt"

            echo "OpenBao initialized. Unseal keys saved to $UNSEAL_KEYS_DIR"
          fi

          # Check if sealed
          SEAL_STATUS=$(curl -sf "$OPENBAO_ADDR/v1/sys/seal-status" | jq -r '.sealed')

          if [ "$SEAL_STATUS" = "true" ]; then
            echo "Unsealing OpenBao..."

            # Read unseal keys
            if [ ! -f "$UNSEAL_KEYS_DIR/unseal-keys.txt" ]; then
              echo "ERROR: Unseal keys not found at $UNSEAL_KEYS_DIR/unseal-keys.txt"
              exit 1
            fi

            # Unseal with first 3 keys
            head -3 "$UNSEAL_KEYS_DIR/unseal-keys.txt" | while read key; do
              curl -sf -X PUT "$OPENBAO_ADDR/v1/sys/unseal" \
                -H "Content-Type: application/json" \
                -d "{\"key\": \"$key\"}"
            done

            echo "OpenBao unsealed"
          fi

          # Get root token for setup
          if [ ! -f "$UNSEAL_KEYS_DIR/root-token.txt" ]; then
            echo "ERROR: Root token not found"
            exit 1
          fi
          ROOT_TOKEN=$(cat "$UNSEAL_KEYS_DIR/root-token.txt")

          # Enable KV secrets engine v2
          echo "Enabling KV secrets engine..."
          curl -sf -X POST "$OPENBAO_ADDR/v1/sys/mounts/secret" \
            -H "X-Vault-Token: $ROOT_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"type": "kv", "options": {"version": "2"}}' || true

          # Enable audit logging
          echo "Enabling audit logging..."
          curl -sf -X PUT "$OPENBAO_ADDR/v1/sys/audit/file" \
            -H "X-Vault-Token: $ROOT_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"type": "file", "options": {"file_path": "/vault/logs/audit.log"}}' || true

          # Enable OIDC auth method
          echo "Enabling OIDC auth method..."
          curl -sf -X POST "$OPENBAO_ADDR/v1/sys/auth/oidc" \
            -H "X-Vault-Token: $ROOT_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"type": "oidc"}' || true

          # Configure OIDC with Keycloak
          echo "Configuring OIDC with Keycloak..."
          curl -sf -X POST "$OPENBAO_ADDR/v1/auth/oidc/config" \
            -H "X-Vault-Token: $ROOT_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "oidc_discovery_url": "'"$KEYCLOAK_URL"'/realms/openclaw",
              "default_role": "openclaw-injector"
            }'

          # Create policies and roles for each instance
          ${concatStringsSep "\n" (builtins.map (name: ''
            echo "Creating policy for instance: ${name}"

            # Create policy
            POLICY_CONTENT=$(cat <<'POLICY_EOF'
            path "secret/data/openclaw/${name}/*" {
              capabilities = ["read"]
            }
            path "secret/metadata/openclaw/${name}/*" {
              capabilities = ["list"]
            }
            POLICY_EOF
            )

            curl -sf -X PUT "$OPENBAO_ADDR/v1/sys/policies/acl/openclaw-${name}" \
              -H "X-Vault-Token: $ROOT_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"policy\": \"$POLICY_CONTENT\"}"

            # Create OIDC role for this instance
            curl -sf -X POST "$OPENBAO_ADDR/v1/auth/oidc/role/openclaw-injector-${name}" \
              -H "X-Vault-Token: $ROOT_TOKEN" \
              -H "Content-Type: application/json" \
              -d '{
                "bound_audiences": ["openclaw-injector-${name}"],
                "allowed_redirect_uris": ["http://localhost:8250/oidc/callback"],
                "user_claim": "sub",
                "policies": ["openclaw-${name}"],
                "ttl": "5m",
                "max_ttl": "10m"
              }'

            echo "Policy and role created for ${name}"
          '') (builtins.attrNames enabledInstances))}

          echo "OpenBao initialization and configuration complete"
        '';
      };
    };

    # OpenBao auto-unseal service (runs on boot)
    systemd.services.openclaw-openbao-unseal = {
      description = "Auto-unseal OpenBao on boot";
      after = [ "podman-openclaw-openbao.service" ];
      requires = [ "podman-openclaw-openbao.service" ];
      before = [ "openclaw-openbao-init.service" ];
      wantedBy = [ "multi-user.target" ];

      path = [ pkgs.curl pkgs.jq ];

      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;

        ExecStart = pkgs.writeShellScript "openclaw-openbao-unseal" ''
          set -euo pipefail

          OPENBAO_ADDR="http://127.0.0.1:${toString openbaoCfg.httpPort}"
          UNSEAL_KEYS_DIR="${openbaoCfg.unsealKeysDir}"

          # Wait for OpenBao to be available
          for i in $(seq 1 30); do
            if curl -sf "$OPENBAO_ADDR/v1/sys/health" >/dev/null 2>&1; then
              break
            fi
            sleep 2
          done

          # Check if sealed
          SEAL_STATUS=$(curl -sf "$OPENBAO_ADDR/v1/sys/seal-status" | jq -r '.sealed')

          if [ "$SEAL_STATUS" = "true" ] && [ -f "$UNSEAL_KEYS_DIR/unseal-keys.txt" ]; then
            echo "Unsealing OpenBao..."
            head -3 "$UNSEAL_KEYS_DIR/unseal-keys.txt" | while read key; do
              curl -sf -X PUT "$OPENBAO_ADDR/v1/sys/unseal" \
                -H "Content-Type: application/json" \
                -d "{\"key\": \"$key\"}"
            done
            echo "OpenBao unsealed"
          elif [ "$SEAL_STATUS" = "false" ]; then
            echo "OpenBao already unsealed"
          else
            echo "Cannot unseal: no unseal keys found (first boot?)"
          fi
        '';
      };
    };
  };
}
