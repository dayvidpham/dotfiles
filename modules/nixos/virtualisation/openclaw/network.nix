# OpenClaw Network Security Configuration
# Configures isolated Podman networks and firewall rules
{ config
, pkgs
, lib ? pkgs.lib
, ...
}:
let
  cfg = config.CUSTOM.virtualisation.openclaw;
  networkCfg = cfg.network;

  inherit (lib)
    mkIf
    mkOption
    mkEnableOption
    mkMerge
    types
    concatMapStringsSep
    optionalString
    ;

  # Generate nftables rules for OpenClaw network isolation
  # Note: networking.nftables.tables wraps this in `table inet openclaw-firewall { ... }`
  nftablesRules = ''
    # OpenClaw Network Security Rules
    # Generated by NixOS openclaw module

    # Allowlisted outbound destinations
    set allowed_hosts {
      type ipv4_addr
      flags interval
      # Anthropic API endpoints (resolved at build time)
      # Note: In production, use DNS resolution or CDN IPs
      elements = { ${concatMapStringsSep ", " (h: h) networkCfg.allowlist.hosts} }
    }

    set allowed_domains_v4 {
      type ipv4_addr
      flags interval
    }

    chain openclaw_output {
      type filter hook output priority 0; policy accept;

      # Allow all loopback traffic
      oifname "lo" accept

      # Allow established/related connections
      ct state established,related accept

      # Allow DNS for name resolution (required for API calls)
      ${optionalString networkCfg.allowlist.allowDns ''
      udp dport 53 accept
      tcp dport 53 accept
      ''}

      # Allow traffic to explicitly allowlisted hosts
      ip daddr @allowed_hosts accept

      # Allow HTTPS to configured domains
      tcp dport 443 ip daddr @allowed_hosts accept

      # Allow inter-container communication on bridge network
      oifname "openclaw-bridge" accept

      # Drop all other outbound traffic from OpenClaw containers
      # Note: This requires marking packets from the containers
      # which is handled by the container network namespace
    }

    chain openclaw_input {
      type filter hook input priority 0; policy accept;

      # Allow loopback
      iifname "lo" accept

      # Allow established/related
      ct state established,related accept

      # Allow WebChat ports (localhost only)
      ${concatMapStringsSep "\n      " (instance:
        let instCfg = cfg.instances.${instance};
        in optionalString instCfg.enable ''
        tcp dport ${toString instCfg.ports.webchat} ip saddr 127.0.0.1 accept comment "WebChat ${instance}"
        tcp dport ${toString instCfg.ports.gateway} ip saddr 127.0.0.1 accept comment "Gateway ${instance}"
        ''
      ) (builtins.attrNames cfg.instances)}

      # Block external access to OpenClaw ports
      ${concatMapStringsSep "\n      " (instance:
        let instCfg = cfg.instances.${instance};
        in optionalString instCfg.enable ''
        tcp dport ${toString instCfg.ports.webchat} drop comment "Block external WebChat ${instance}"
        tcp dport ${toString instCfg.ports.gateway} drop comment "Block external Gateway ${instance}"
        ''
      ) (builtins.attrNames cfg.instances)}
    }
  '';

in
{
  options.CUSTOM.virtualisation.openclaw.network = {
    enable = mkEnableOption "OpenClaw network security configuration" // { default = true; };

    bridgeNetwork = {
      name = mkOption {
        type = types.str;
        default = "openclaw-bridge";
        description = "Name of the internal Podman network for inter-instance communication";
      };

      subnet = mkOption {
        type = types.str;
        default = "10.89.0.0/24";
        description = "Subnet for the internal bridge network";
      };

      gateway = mkOption {
        type = types.str;
        default = "10.89.0.1";
        description = "Gateway IP for the bridge network";
      };
    };

    allowlist = {
      hosts = mkOption {
        type = types.listOf types.str;
        default = [
          # Anthropic API
          "160.79.104.0/23"   # api.anthropic.com approximate range
        ];
        description = "IP addresses/ranges allowed for outbound connections";
      };

      domains = mkOption {
        type = types.listOf types.str;
        default = [
          "api.anthropic.com"
        ];
        description = "Domain names allowed for outbound connections (resolved at runtime)";
      };

      allowDns = mkOption {
        type = types.bool;
        default = true;
        description = "Allow DNS queries (required for domain resolution)";
      };
    };

    strictFirewall = mkOption {
      type = types.bool;
      default = true;
      description = "Enable strict firewall rules blocking non-allowlisted outbound traffic";
    };
  };

  config = mkIf (cfg.enable && networkCfg.enable) {
    # Ensure nftables is enabled
    networking.nftables.enable = true;

    # Add OpenClaw-specific firewall rules
    networking.nftables.tables.openclaw-firewall = mkIf networkCfg.strictFirewall {
      family = "inet";
      content = nftablesRules;
    };

    # Open ports for localhost access only (handled by nftables rules above)
    # These are informational - actual filtering is done by nftables
    networking.firewall = {
      # Don't open these ports to external interfaces
      # They're only accessible via localhost per nftables rules
    };

    # Create Podman network for inter-instance communication
    # This is done via systemd service since NixOS doesn't have native podman network management
    systemd.services.openclaw-network-setup = {
      description = "Create OpenClaw Podman bridge network";
      after = [ "podman.service" ];
      requires = [ "podman.service" ];
      wantedBy = [ "multi-user.target" ];

      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;
        ExecStart = pkgs.writeShellScript "openclaw-network-create" ''
          ${pkgs.podman}/bin/podman network exists ${networkCfg.bridgeNetwork.name} || \
          ${pkgs.podman}/bin/podman network create \
            --driver bridge \
            --subnet ${networkCfg.bridgeNetwork.subnet} \
            --gateway ${networkCfg.bridgeNetwork.gateway} \
            --internal \
            ${networkCfg.bridgeNetwork.name}
        '';
        ExecStop = "${pkgs.podman}/bin/podman network rm -f ${networkCfg.bridgeNetwork.name} || true";
      };
    };
  };
}
