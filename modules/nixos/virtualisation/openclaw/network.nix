# OpenClaw Network Security Configuration
# Configures isolated Podman networks and firewall rules
{ config
, pkgs
, lib ? pkgs.lib
, ...
}:
let
  cfg = config.CUSTOM.virtualisation.openclaw;
  networkCfg = cfg.network;

  inherit (lib)
    mkIf
    mkOption
    mkEnableOption
    mkMerge
    types
    concatMapStringsSep
    optionalString
    ;

  # Generate nftables rules for OpenClaw network isolation
  # Note: networking.nftables.tables wraps this in `table inet openclaw-firewall { ... }`
  #
  # IMPORTANT: These nftables rules protect HOST services from container access,
  # but do NOT restrict container EGRESS. Rootless podman uses slirp4netns/pasta
  # which bypasses host nftables. Container egress relies on:
  # 1. The --internal flag on podman networks (no external routing)
  # 2. DNS-based restrictions (if implemented in container)
  # For true egress control, use rootful podman or container-level firewall.
  nftablesRules = ''
    # OpenClaw Network Security Rules
    # Generated by NixOS openclaw module

    # Allowlisted outbound destinations
    set allowed_hosts {
      type ipv4_addr
      flags interval
      # Anthropic API endpoints (resolved at build time)
      # Note: In production, use DNS resolution or CDN IPs
      elements = { ${concatMapStringsSep ", " (h: h) networkCfg.allowlist.hosts} }
    }

    set allowed_domains_v4 {
      type ipv4_addr
      flags interval
    }

    chain openclaw_output {
      type filter hook output priority 0; policy accept;

      # Allow all loopback traffic
      oifname "lo" accept

      # Allow established/related connections
      ct state established,related accept

      # Allow DNS for name resolution (required for API calls)
      ${optionalString networkCfg.allowlist.allowDns ''
      # Only allow DNS to local resolver (prevent DNS tunneling)
      udp dport 53 ip daddr 127.0.0.53 accept
      tcp dport 53 ip daddr 127.0.0.53 accept
      ''}

      # Allow traffic to explicitly allowlisted hosts
      ip daddr @allowed_hosts accept

      # Allow HTTPS to configured domains
      tcp dport 443 ip daddr @allowed_hosts accept

      # Allow inter-container communication on bridge network
      oifname "openclaw-bridge" accept

      # Drop all other outbound traffic from OpenClaw containers
      # Note: This requires marking packets from the containers
      # which is handled by the container network namespace
    }

    # Zero-Trust Network Isolation
    # Block container network from reaching secrets infrastructure
    # Defense in depth: services are bound to 127.0.0.1, but explicit block
    ${optionalString cfg.zeroTrust.enable ''
    chain openclaw_forward {
      type filter hook forward priority 0; policy accept;

      # Block container subnet from reaching Keycloak
      ip saddr ${networkCfg.bridgeNetwork.subnet} tcp dport ${toString networkCfg.zeroTrust.keycloakPort} drop comment "Block containers->Keycloak"

      # Block container subnet from reaching OpenBao
      ip saddr ${networkCfg.bridgeNetwork.subnet} tcp dport ${toString networkCfg.zeroTrust.openbaoPort} drop comment "Block containers->OpenBao"

      # Block container subnet from reaching secrets network
      ip saddr ${networkCfg.bridgeNetwork.subnet} ip daddr ${networkCfg.zeroTrust.secretsNetworkSubnet} drop comment "Block containers->secrets-network"
    }
    ''}

    chain openclaw_input {
      type filter hook input priority 0; policy accept;

      # Allow loopback
      iifname "lo" accept

      # Allow established/related
      ct state established,related accept

      # Allow WebChat ports (localhost only)
      ${concatMapStringsSep "\n      " (instance:
        let instCfg = cfg.instances.${instance};
        in optionalString instCfg.enable ''
        tcp dport ${toString instCfg.ports.webchat} ip saddr 127.0.0.1 accept comment "WebChat ${instance}"
        tcp dport ${toString instCfg.ports.gateway} ip saddr 127.0.0.1 accept comment "Gateway ${instance}"
        ''
      ) (builtins.attrNames cfg.instances)}

      # Block external access to OpenClaw ports
      ${concatMapStringsSep "\n      " (instance:
        let instCfg = cfg.instances.${instance};
        in optionalString instCfg.enable ''
        tcp dport ${toString instCfg.ports.webchat} drop comment "Block external WebChat ${instance}"
        tcp dport ${toString instCfg.ports.gateway} drop comment "Block external Gateway ${instance}"
        ''
      ) (builtins.attrNames cfg.instances)}
    }
  '';

in
{
  options.CUSTOM.virtualisation.openclaw.network = {
    enable = mkEnableOption "OpenClaw network security configuration" // { default = true; };

    bridgeNetwork = {
      name = mkOption {
        type = types.str;
        default = "openclaw-bridge";
        description = "Name of the internal Podman network for inter-instance communication";
      };

      subnet = mkOption {
        type = types.str;
        default = "10.89.0.0/24";
        description = "Subnet for the internal bridge network";
      };

      gateway = mkOption {
        type = types.str;
        default = "10.89.0.1";
        description = "Gateway IP for the bridge network";
      };
    };

    allowlist = {
      hosts = mkOption {
        type = types.listOf types.str;
        default = [
          # Anthropic API
          # WARNING: This IP range is APPROXIMATE and may change without notice.
          # Anthropic uses CDN/cloud infrastructure with dynamic IPs.
          # Monitor API connectivity and update this range if connections fail.
          # Consider using DNS resolution or consult Anthropic's network documentation.
          "160.79.104.0/23"   # api.anthropic.com approximate range
        ];
        description = ''
          IP addresses/ranges allowed for outbound connections.
          Note: Anthropic API IP ranges may change. This is an approximate range
          and should be updated based on actual infrastructure changes.
        '';
      };

      domains = mkOption {
        type = types.listOf types.str;
        default = [
          "api.anthropic.com"
        ];
        description = "Domain names allowed for outbound connections (resolved at runtime)";
      };

      allowDns = mkOption {
        type = types.bool;
        default = true;
        description = "Allow DNS queries (required for domain resolution)";
      };
    };

    strictFirewall = mkOption {
      type = types.bool;
      default = true;
      description = "Enable strict firewall rules blocking non-allowlisted outbound traffic";
    };

    # Zero-trust network isolation settings
    zeroTrust = {
      keycloakPort = mkOption {
        type = types.port;
        default = 8080;
        description = "Keycloak port to block from containers (defense in depth)";
      };

      openbaoPort = mkOption {
        type = types.port;
        default = 8200;
        description = "OpenBao port to block from containers (defense in depth)";
      };

      secretsNetworkSubnet = mkOption {
        type = types.str;
        default = "10.90.0.0/24";
        description = "Secrets infrastructure network subnet to block from containers";
      };
    };
  };

  config = mkIf (cfg.enable && networkCfg.enable) {
    # Ensure nftables is enabled
    networking.nftables.enable = true;

    # Add OpenClaw-specific firewall rules
    networking.nftables.tables.openclaw-firewall = mkIf networkCfg.strictFirewall {
      family = "inet";
      content = nftablesRules;
    };

    # Open ports for localhost access only (handled by nftables rules above)
    # These are informational - actual filtering is done by nftables
    networking.firewall = {
      # Don't open these ports to external interfaces
      # They're only accessible via localhost per nftables rules
    };

    # NOTE: Root-level network setup is DISABLED for rootless podman.
    # Rootless podman uses per-user network namespaces, so a root-created network
    # would be invisible to instance containers running as dedicated users.
    # Each instance creates its own network in instance.nix ExecStartPre (lines 184-191).
    #
    # This service definition is kept for reference/documentation only.
    # If you need rootful podman in the future, uncomment this service.
    #
    # systemd.services.openclaw-network-setup = {
    #   description = "Create OpenClaw Podman bridge network (ROOTFUL ONLY)";
    #   after = [ "podman.service" ];
    #   requires = [ "podman.service" ];
    #   wantedBy = [ "multi-user.target" ];
    #
    #   serviceConfig = {
    #     Type = "oneshot";
    #     RemainAfterExit = true;
    #     ExecStart = pkgs.writeShellScript "openclaw-network-create" ''
    #       ${pkgs.podman}/bin/podman network exists ${networkCfg.bridgeNetwork.name} || \
    #       ${pkgs.podman}/bin/podman network create \
    #         --driver bridge \
    #         --subnet ${networkCfg.bridgeNetwork.subnet} \
    #         --gateway ${networkCfg.bridgeNetwork.gateway} \
    #         --internal \
    #         ${networkCfg.bridgeNetwork.name}
    #     '';
    #     ExecStop = "${pkgs.podman}/bin/podman network rm -f ${networkCfg.bridgeNetwork.name} || true";
    #   };
    # };
  };
}
