# Standalone OpenBao Secrets Store Module
# Deploys OpenBao (open-source Vault fork) in a Podman container
# This module is GENERIC and can be used by any service, not just OpenClaw
#
# Design principles:
# - No hardcoded application-specific names (paths, service names)
# - All configuration is parameterized via options
# - Keycloak is OPTIONAL (supports token auth for standalone use)
# - Policies are explicitly defined, not derived from parent module
{ config
, pkgs
, lib ? pkgs.lib
, ...
}:
let
  cfg = config.CUSTOM.virtualisation.openbao;

  inherit (lib)
    mkIf
    mkOption
    mkEnableOption
    types
    concatStringsSep
    optionalString
    ;

  # OpenBao server configuration
  openbaoConfig = pkgs.writeText "openbao-config.hcl" ''
    # OpenBao Server Configuration
    # Generated by NixOS module

    storage "file" {
      path = "/vault/data"
    }

    listener "tcp" {
      address     = "0.0.0.0:8200"
      tls_disable = ${if cfg.tlsDisable then "true" else "false"}
    }

    # API address for clients
    api_addr = "http://${cfg.servicePrefix}-openbao:8200"

    # Cluster address (single node)
    cluster_addr = "http://${cfg.servicePrefix}-openbao:8201"

    # Disable mlock for container environment
    disable_mlock = true

    # UI for debugging (can be disabled in production)
    ui = ${if cfg.enableUI then "true" else "false"}

    # Telemetry for monitoring
    telemetry {
      disable_hostname = true
    }

    # Audit logging
    log_level = "${cfg.logLevel}"
  '';

  openbaoImage = "quay.io/openbao/openbao:2.1";

  # Service name prefix
  svcPrefix = cfg.servicePrefix;

in
{
  options.CUSTOM.virtualisation.openbao = {
    enable = mkEnableOption "OpenBao secrets store";

    # Server configuration
    httpPort = mkOption {
      type = types.port;
      default = 8200;
      description = "HTTP API port for OpenBao (internal only)";
    };

    enableUI = mkOption {
      type = types.bool;
      default = false;
      description = "Enable OpenBao web UI (for debugging only)";
    };

    tlsDisable = mkOption {
      type = types.bool;
      default = true;
      description = "Disable TLS (for internal network only)";
    };

    logLevel = mkOption {
      type = types.enum [ "trace" "debug" "info" "warn" "error" ];
      default = "info";
      description = "Log level for OpenBao";
    };

    # Storage configuration
    dataDir = mkOption {
      type = types.path;
      default = /var/lib/openbao;
      description = "Directory for OpenBao data";
    };

    # Service naming
    servicePrefix = mkOption {
      type = types.str;
      default = "openbao";
      description = "Prefix for systemd service names";
      example = "myapp-openbao";
    };

    # Authentication configuration
    auth = {
      method = mkOption {
        type = types.enum [ "oidc" "token" "none" ];
        default = "oidc";
        description = ''
          Authentication method:
          - oidc: Use Keycloak OIDC (requires keycloak config)
          - token: Static token authentication
          - none: No external auth (root token only)
        '';
      };

      oidc = {
        enable = mkOption {
          type = types.bool;
          default = false;
          description = "Enable OIDC authentication with Keycloak";
        };

        discoveryUrl = mkOption {
          type = types.str;
          default = "";
          description = "OIDC discovery URL (e.g., http://keycloak:8080/realms/myrealm)";
          example = "http://127.0.0.1:8080/realms/myapp";
        };

        defaultRole = mkOption {
          type = types.str;
          default = "default";
          description = "Default OIDC role for authentication";
        };
      };
    };

    # Unseal configuration
    autoUnseal = mkOption {
      type = types.bool;
      default = true;
      description = "Automatically unseal OpenBao on startup using stored keys";
    };

    unsealKeysDir = mkOption {
      type = types.path;
      default = /var/lib/openbao/unseal-keys;
      description = "Directory to store unseal keys (protected, root-only)";
    };

    unsealKeyEncryption = mkOption {
      type = types.bool;
      default = false;
      description = "Whether unseal keys should be encrypted via sops-nix (requires external integration)";
    };

    # Policy definitions
    policies = mkOption {
      type = types.listOf (types.submodule {
        options = {
          name = mkOption {
            type = types.str;
            description = "Policy name";
            example = "api-service";
          };
          paths = mkOption {
            type = types.listOf types.str;
            description = "Secret paths this policy can access";
            example = [ "secret/data/api/*" "secret/metadata/api/*" ];
          };
          capabilities = mkOption {
            type = types.listOf (types.enum [ "create" "read" "update" "delete" "list" "sudo" "deny" ]);
            default = [ "read" ];
            description = "Capabilities for the paths";
          };
        };
      });
      default = [];
      description = "List of policies to create";
      example = [
        { name = "api"; paths = [ "secret/data/api/*" ]; capabilities = [ "read" ]; }
        { name = "admin"; paths = [ "secret/*" ]; capabilities = [ "create" "read" "update" "delete" "list" ]; }
      ];
    };

    # OIDC roles (only used when auth.method = "oidc")
    oidcRoles = mkOption {
      type = types.listOf (types.submodule {
        options = {
          name = mkOption {
            type = types.str;
            description = "OIDC role name";
          };
          boundAudiences = mkOption {
            type = types.listOf types.str;
            description = "Allowed client IDs (audiences)";
          };
          policies = mkOption {
            type = types.listOf types.str;
            description = "Policies to attach to this role";
          };
          ttl = mkOption {
            type = types.str;
            default = "5m";
            description = "Token TTL";
          };
          maxTtl = mkOption {
            type = types.str;
            default = "10m";
            description = "Maximum token TTL";
          };
        };
      });
      default = [];
      description = "OIDC roles for Keycloak integration";
    };

    # Network configuration
    network = {
      name = mkOption {
        type = types.str;
        default = "openbao";
        description = "Podman network name (can be shared with Keycloak)";
      };

      createNetwork = mkOption {
        type = types.bool;
        default = true;
        description = "Create the network (set false if using shared network from Keycloak)";
      };

      subnet = mkOption {
        type = types.str;
        default = "10.91.0.0/24";
        description = "Subnet for OpenBao network (only if createNetwork=true)";
      };

      gateway = mkOption {
        type = types.str;
        default = "10.91.0.1";
        description = "Gateway for OpenBao network";
      };
    };

    # Audit logging
    auditLogPath = mkOption {
      type = types.path;
      default = /var/log/openbao/audit.log;
      description = "Path to OpenBao audit log";
    };
  };

  config = mkIf cfg.enable {
    # Create data directories
    systemd.tmpfiles.rules = [
      "d ${cfg.dataDir} 0700 100 100 -"  # UID 100 = vault user in container
      "d ${cfg.dataDir}/data 0700 100 100 -"
      "d ${cfg.dataDir}/logs 0700 100 100 -"
      "d ${cfg.dataDir}/config 0700 100 100 -"
      "d ${cfg.unsealKeysDir} 0700 root root -"
      "d ${builtins.dirOf cfg.auditLogPath} 0750 root root -"
    ];

    # Create the OpenBao network (if enabled)
    systemd.services."${svcPrefix}-network" = mkIf cfg.network.createNetwork {
      description = "Create ${svcPrefix} Network";
      after = [ "podman.service" ];
      requires = [ "podman.service" ];
      before = [ "podman-${svcPrefix}.service" ];
      wantedBy = [ "multi-user.target" ];

      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;
        ExecStart = pkgs.writeShellScript "${svcPrefix}-network-create" ''
          ${pkgs.podman}/bin/podman network exists ${cfg.network.name} || \
          ${pkgs.podman}/bin/podman network create \
            --driver bridge \
            --subnet ${cfg.network.subnet} \
            --gateway ${cfg.network.gateway} \
            --internal \
            ${cfg.network.name}
        '';
        ExecStop = "${pkgs.podman}/bin/podman network rm -f ${cfg.network.name} || true";
      };
    };

    # OpenBao container
    systemd.services."podman-${svcPrefix}" = {
      description = "OpenBao Secrets Store";
      after = [ "podman.service" ]
        ++ (if cfg.network.createNetwork then [ "${svcPrefix}-network.service" ] else []);
      requires = [ "podman.service" ]
        ++ (if cfg.network.createNetwork then [ "${svcPrefix}-network.service" ] else []);
      wantedBy = [ "multi-user.target" ];

      serviceConfig = {
        Type = "simple";
        Restart = "always";
        RestartSec = "10s";

        ExecStart = pkgs.writeShellScript "${svcPrefix}-start" ''
          set -euo pipefail

          # Copy config to container-accessible location
          cp ${openbaoConfig} ${cfg.dataDir}/config/openbao.hcl
          chmod 644 ${cfg.dataDir}/config/openbao.hcl
          chown 100:100 ${cfg.dataDir}/config/openbao.hcl

          exec ${pkgs.podman}/bin/podman run \
            --name ${svcPrefix} \
            --replace \
            --network ${cfg.network.name} \
            --publish "127.0.0.1:${toString cfg.httpPort}:8200" \
            --volume "${cfg.dataDir}/data:/vault/data:rw" \
            --volume "${cfg.dataDir}/logs:/vault/logs:rw" \
            --volume "${cfg.dataDir}/config:/vault/config:ro" \
            --env "BAO_ADDR=http://127.0.0.1:8200" \
            --env "BAO_API_ADDR=http://${svcPrefix}:8200" \
            --cap-add IPC_LOCK \
            --health-cmd "bao status -format=json | grep -q '\"sealed\":false' || exit 1" \
            --health-interval 30s \
            --health-retries 3 \
            --security-opt "no-new-privileges:true" \
            ${openbaoImage} \
            server -config=/vault/config/openbao.hcl
        '';

        ExecStop = "${pkgs.podman}/bin/podman stop -t 30 ${svcPrefix}";
        ExecStopPost = "${pkgs.podman}/bin/podman rm -f ${svcPrefix} || true";
      };
    };

    # OpenBao auto-unseal service (runs on boot)
    systemd.services."${svcPrefix}-unseal" = mkIf cfg.autoUnseal {
      description = "Auto-unseal OpenBao on boot";
      after = [ "podman-${svcPrefix}.service" ];
      requires = [ "podman-${svcPrefix}.service" ];
      before = [ "${svcPrefix}-init.service" ];
      wantedBy = [ "multi-user.target" ];

      path = [ pkgs.curl pkgs.jq ];

      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;

        ExecStart = pkgs.writeShellScript "${svcPrefix}-unseal" ''
          set -euo pipefail

          OPENBAO_ADDR="http://127.0.0.1:${toString cfg.httpPort}"
          UNSEAL_KEYS_DIR="${cfg.unsealKeysDir}"

          # Wait for OpenBao to be available
          echo "Waiting for OpenBao to be available..."
          for i in $(seq 1 30); do
            if curl -sf "$OPENBAO_ADDR/v1/sys/health" >/dev/null 2>&1; then
              echo "OpenBao is available"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "OpenBao failed to become available (may not be initialized yet)"
              exit 0  # Don't fail, init service will handle it
            fi
            sleep 2
          done

          # Check if sealed
          SEAL_STATUS=$(curl -sf "$OPENBAO_ADDR/v1/sys/seal-status" | jq -r '.sealed')

          if [ "$SEAL_STATUS" = "true" ] && [ -f "$UNSEAL_KEYS_DIR/unseal-keys.txt" ]; then
            echo "Unsealing OpenBao..."
            head -3 "$UNSEAL_KEYS_DIR/unseal-keys.txt" | while read key; do
              curl -sf -X PUT "$OPENBAO_ADDR/v1/sys/unseal" \
                -H "Content-Type: application/json" \
                -d "{\"key\": \"$key\"}" || true
            done
            echo "OpenBao unsealed"
          elif [ "$SEAL_STATUS" = "false" ]; then
            echo "OpenBao already unsealed"
          else
            echo "Cannot unseal: no unseal keys found (first boot?)"
          fi
        '';
      };
    };

    # OpenBao initialization and configuration service
    systemd.services."${svcPrefix}-init" = {
      description = "Initialize OpenBao and Configure Authentication";
      after = [ "podman-${svcPrefix}.service" ]
        ++ (if cfg.autoUnseal then [ "${svcPrefix}-unseal.service" ] else []);
      requires = [ "podman-${svcPrefix}.service" ];
      wantedBy = [ "multi-user.target" ];

      path = [ pkgs.curl pkgs.jq pkgs.coreutils ];

      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;

        ExecStart = pkgs.writeShellScript "${svcPrefix}-init" ''
          set -euo pipefail

          OPENBAO_ADDR="http://127.0.0.1:${toString cfg.httpPort}"
          UNSEAL_KEYS_DIR="${cfg.unsealKeysDir}"

          # Wait for OpenBao to be available
          echo "Waiting for OpenBao to be available..."
          for i in $(seq 1 30); do
            if curl -sf "$OPENBAO_ADDR/v1/sys/health" >/dev/null 2>&1; then
              echo "OpenBao is available"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "OpenBao failed to become available"
              exit 1
            fi
            sleep 2
          done

          # Check if already initialized
          INIT_STATUS=$(curl -sf "$OPENBAO_ADDR/v1/sys/init" | jq -r '.initialized')

          if [ "$INIT_STATUS" = "false" ]; then
            echo "Initializing OpenBao..."

            # Initialize with 5 key shares, 3 threshold
            INIT_RESPONSE=$(curl -sf -X PUT "$OPENBAO_ADDR/v1/sys/init" \
              -H "Content-Type: application/json" \
              -d '{"secret_shares": 5, "secret_threshold": 3}')

            # Save unseal keys and root token securely
            mkdir -p "$UNSEAL_KEYS_DIR"
            echo "$INIT_RESPONSE" | jq -r '.keys[]' > "$UNSEAL_KEYS_DIR/unseal-keys.txt"
            echo "$INIT_RESPONSE" | jq -r '.root_token' > "$UNSEAL_KEYS_DIR/root-token.txt"
            chmod 400 "$UNSEAL_KEYS_DIR/unseal-keys.txt" "$UNSEAL_KEYS_DIR/root-token.txt"

            echo "OpenBao initialized. Unseal keys saved to $UNSEAL_KEYS_DIR"

            # Unseal immediately after init
            echo "Unsealing OpenBao..."
            head -3 "$UNSEAL_KEYS_DIR/unseal-keys.txt" | while read key; do
              curl -sf -X PUT "$OPENBAO_ADDR/v1/sys/unseal" \
                -H "Content-Type: application/json" \
                -d "{\"key\": \"$key\"}"
            done
          fi

          # Check if sealed
          SEAL_STATUS=$(curl -sf "$OPENBAO_ADDR/v1/sys/seal-status" | jq -r '.sealed')
          if [ "$SEAL_STATUS" = "true" ]; then
            echo "ERROR: OpenBao is still sealed. Cannot continue configuration."
            exit 1
          fi

          # Get root token for setup
          if [ ! -f "$UNSEAL_KEYS_DIR/root-token.txt" ]; then
            echo "ERROR: Root token not found"
            exit 1
          fi
          ROOT_TOKEN=$(cat "$UNSEAL_KEYS_DIR/root-token.txt")

          # Enable KV secrets engine v2
          echo "Enabling KV secrets engine..."
          curl -sf -X POST "$OPENBAO_ADDR/v1/sys/mounts/secret" \
            -H "X-Vault-Token: $ROOT_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"type": "kv", "options": {"version": "2"}}' || true

          # Enable audit logging
          echo "Enabling audit logging..."
          curl -sf -X PUT "$OPENBAO_ADDR/v1/sys/audit/file" \
            -H "X-Vault-Token: $ROOT_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"type": "file", "options": {"file_path": "/vault/logs/audit.log"}}' || true

          ${optionalString (cfg.auth.method == "oidc" && cfg.auth.oidc.enable) ''
            # Enable OIDC auth method
            echo "Enabling OIDC auth method..."
            curl -sf -X POST "$OPENBAO_ADDR/v1/sys/auth/oidc" \
              -H "X-Vault-Token: $ROOT_TOKEN" \
              -H "Content-Type: application/json" \
              -d '{"type": "oidc"}' || true

            # Configure OIDC
            echo "Configuring OIDC..."
            curl -sf -X POST "$OPENBAO_ADDR/v1/auth/oidc/config" \
              -H "X-Vault-Token: $ROOT_TOKEN" \
              -H "Content-Type: application/json" \
              -d '{
                "oidc_discovery_url": "${cfg.auth.oidc.discoveryUrl}",
                "default_role": "${cfg.auth.oidc.defaultRole}"
              }'
          ''}

          # Create policies
          ${concatStringsSep "\n" (builtins.map (policy: ''
            echo "Creating policy: ${policy.name}"
            POLICY_CONTENT='${concatStringsSep "\n" (builtins.map (path: ''
              path "${path}" {
                capabilities = [${concatStringsSep ", " (builtins.map (c: "\"${c}\"") policy.capabilities)}]
              }
            '') policy.paths)}'

            curl -sf -X PUT "$OPENBAO_ADDR/v1/sys/policies/acl/${policy.name}" \
              -H "X-Vault-Token: $ROOT_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"policy\": $(echo "$POLICY_CONTENT" | jq -Rs .)}"
          '') cfg.policies)}

          ${optionalString (cfg.auth.method == "oidc" && cfg.auth.oidc.enable) ''
            # Create OIDC roles
            ${concatStringsSep "\n" (builtins.map (role: ''
              echo "Creating OIDC role: ${role.name}"
              curl -sf -X POST "$OPENBAO_ADDR/v1/auth/oidc/role/${role.name}" \
                -H "X-Vault-Token: $ROOT_TOKEN" \
                -H "Content-Type: application/json" \
                -d '{
                  "bound_audiences": [${concatStringsSep ", " (builtins.map (a: "\"${a}\"") role.boundAudiences)}],
                  "allowed_redirect_uris": ["http://localhost:8250/oidc/callback"],
                  "user_claim": "sub",
                  "policies": [${concatStringsSep ", " (builtins.map (p: "\"${p}\"") role.policies)}],
                  "ttl": "${role.ttl}",
                  "max_ttl": "${role.maxTtl}"
                }'
            '') cfg.oidcRoles)}
          ''}

          echo "OpenBao initialization and configuration complete"
        '';
      };
    };
  };
}
