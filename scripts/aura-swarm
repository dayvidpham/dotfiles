#!/usr/bin/env python3
"""
aura-swarm — Automated worktree agent workflow.

Creates an isolated git worktree for an epic, gathers beads task context,
and launches a single Claude instance that uses Agent Teams internally
to coordinate workers.

Branch model:
    main
     └── epic/<epic-id>                 (aura-swarm creates this branch + worktree)
          ├── agent/<task-id-1>         (Claude's Agent Teams creates these)
          ├── agent/<task-id-2>
          └── agent/<task-id-3>

Usage:
    aura-swarm start --epic aura-dyu --model sonnet
    aura-swarm status
    aura-swarm attach aura-dyu
    aura-swarm stop aura-dyu
    aura-swarm merge aura-dyu
    aura-swarm review --epic aura-dyu
    aura-swarm cleanup aura-dyu
    aura-swarm cleanup --done
    aura-swarm cleanup --all
"""

from __future__ import annotations

import argparse
import hashlib
import json
import os
import secrets
import signal
import subprocess
import sys
import textwrap
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, NamedTuple

# ──────────────────────────────────────────────
# Constants
# ──────────────────────────────────────────────

VALID_ROLES = frozenset(["architect", "supervisor", "reviewer", "worker"])
VALID_MODELS = frozenset(["sonnet", "opus", "haiku"])
AURA_STATE_DIR = Path.home() / ".aura" / "swarm"
DEFAULT_WORKTREE_DIR = "worktree"
DEFAULT_ROLE = "supervisor"
DEFAULT_MODEL = "sonnet"

_interrupted = False


# ──────────────────────────────────────────────
# Data types
# ──────────────────────────────────────────────


class SessionEntry:
    """One active swarm session."""

    __slots__ = (
        "epic_id",
        "epic_branch",
        "worktree",
        "tmux_session",
        "started_at",
        "model",
        "task_ids",
    )

    def __init__(
        self,
        *,
        epic_id: str,
        epic_branch: str,
        worktree: str,
        tmux_session: str,
        started_at: str,
        model: str,
        task_ids: list[str],
    ) -> None:
        self.epic_id = epic_id
        self.epic_branch = epic_branch
        self.worktree = worktree
        self.tmux_session = tmux_session
        self.started_at = started_at
        self.model = model
        self.task_ids = task_ids

    def to_dict(self) -> dict[str, Any]:
        return {
            "epic_id": self.epic_id,
            "epic_branch": self.epic_branch,
            "worktree": self.worktree,
            "tmux_session": self.tmux_session,
            "started_at": self.started_at,
            "model": self.model,
            "task_ids": self.task_ids,
        }

    @classmethod
    def from_dict(cls, d: dict[str, Any]) -> SessionEntry:
        return cls(
            epic_id=d["epic_id"],
            epic_branch=d["epic_branch"],
            worktree=d["worktree"],
            tmux_session=d["tmux_session"],
            started_at=d["started_at"],
            model=d["model"],
            task_ids=d.get("task_ids", []),
        )


class SessionsFile:
    """Manages the sessions.json state file for a given repo."""

    def __init__(self, repo_root: Path) -> None:
        self.repo_root = repo_root
        repo_hash = hashlib.sha256(str(repo_root).encode()).hexdigest()[:16]
        self.state_dir = AURA_STATE_DIR / repo_hash
        self.file_path = self.state_dir / "sessions.json"

    def load(self) -> dict[str, Any]:
        if not self.file_path.exists():
            return {"repo_root": str(self.repo_root), "sessions": []}
        with open(self.file_path) as f:
            return json.load(f)

    def save(self, data: dict[str, Any]) -> None:
        self.state_dir.mkdir(parents=True, exist_ok=True)
        tmp = self.file_path.with_suffix(".tmp")
        with open(tmp, "w") as f:
            json.dump(data, f, indent=2)
            f.write("\n")
        tmp.rename(self.file_path)

    def get_sessions(self) -> list[SessionEntry]:
        data = self.load()
        return [SessionEntry.from_dict(s) for s in data.get("sessions", [])]

    def add_session(self, entry: SessionEntry) -> None:
        data = self.load()
        data["sessions"].append(entry.to_dict())
        self.save(data)

    def remove_session(self, epic_id: str) -> bool:
        data = self.load()
        before = len(data["sessions"])
        data["sessions"] = [s for s in data["sessions"] if s["epic_id"] != epic_id]
        if len(data["sessions"]) < before:
            self.save(data)
            return True
        return False

    def find_session(self, epic_id: str) -> SessionEntry | None:
        for s in self.get_sessions():
            if s.epic_id == epic_id:
                return s
        return None


# ──────────────────────────────────────────────
# Helpers
# ──────────────────────────────────────────────


def signal_handler(signum: int, frame: Any) -> None:
    global _interrupted
    _interrupted = True
    print("\nInterrupted.", file=sys.stderr)


def run_command(
    cmd: list[str], *, capture: bool = False, cwd: str | Path | None = None
) -> subprocess.CompletedProcess[str]:
    if capture:
        return subprocess.run(cmd, capture_output=True, text=True, cwd=cwd)
    return subprocess.run(cmd, text=True, cwd=cwd)


def get_git_root() -> Path | None:
    result = run_command(["git", "rev-parse", "--show-toplevel"], capture=True)
    if result.returncode == 0:
        return Path(result.stdout.strip())
    return None


def check_tmux_session_exists(session_name: str) -> bool:
    result = run_command(["tmux", "has-session", "-t", session_name], capture=True)
    return result.returncode == 0


def generate_tmux_session_name(epic_id: str, max_retries: int = 5) -> str:
    """Generate unique session name: epic-<suffix>--<hex4>."""
    # Extract suffix from epic ID (e.g. "aura-dyu" -> "dyu")
    parts = epic_id.split("-", 1)
    suffix = parts[1] if len(parts) > 1 else epic_id

    for _ in range(max_retries):
        hex4 = secrets.token_hex(2)
        name = f"epic-{suffix}--{hex4}"
        if not check_tmux_session_exists(name):
            return name
    raise RuntimeError(f"Failed to generate unique tmux session name after {max_retries} retries")


class LaunchResult(NamedTuple):
    """Result of launching a tmux session."""
    session_name: str
    success: bool
    error: str | None = None


def get_role_instructions(role: str, working_dir: Path) -> tuple[str | None, Path | None]:
    """Load role instructions from .claude/commands/aura:{role}.md.

    Checks working_dir first, then falls back to ~/.claude/commands/.
    Returns (content, path) tuple. Both are None if file doesn't exist.
    """
    instructions_path = working_dir / f".claude/commands/aura:{role}.md"
    if instructions_path.exists():
        return instructions_path.read_text(), instructions_path

    home_path = Path.home() / f".claude/commands/aura:{role}.md"
    if home_path.exists():
        return home_path.read_text(), home_path

    return None, None


def launch_tmux_session(
    *,
    session_name: str,
    working_dir: Path,
    role_instructions: str,
    prompt: str,
    model: str,
    permission_mode: str = "acceptEdits",
) -> LaunchResult:
    """Launch a Claude agent in a detached tmux session."""
    escaped_prompt = prompt.replace("'", "'\"'\"'")
    escaped_instructions = role_instructions.replace("'", "'\"'\"'")

    claude_cmd = (
        f"claude --model {model} "
        f"--append-system-prompt '{escaped_instructions}' "
        f"--permission-mode {permission_mode} "
        f"'{escaped_prompt}'"
    )
    full_cmd = f"{claude_cmd}; echo ''; echo 'Session complete. Press Enter to close.'; read"

    tmux_cmd = [
        "tmux", "new-session", "-d",
        "-s", session_name,
        "-c", str(working_dir),
        full_cmd,
    ]

    if check_tmux_session_exists(session_name):
        return LaunchResult(session_name, success=False, error=f"Session '{session_name}' already exists")

    result = run_command(tmux_cmd, capture=True)
    if result.returncode != 0:
        error_msg = result.stderr.strip() if result.stderr else "Unknown error"
        return LaunchResult(session_name, success=False, error=error_msg)

    return LaunchResult(session_name, success=True)


def branch_exists(branch: str, *, cwd: str | Path | None = None) -> bool:
    result = run_command(
        ["git", "rev-parse", "--verify", f"refs/heads/{branch}"],
        capture=True,
        cwd=cwd,
    )
    return result.returncode == 0


def branch_merged_into_main(branch: str, *, cwd: str | Path | None = None) -> bool:
    """Check if branch is merged into main (or master)."""
    for main_branch in ("main", "master"):
        result = run_command(
            ["git", "merge-base", "--is-ancestor", branch, main_branch],
            capture=True,
            cwd=cwd,
        )
        if result.returncode == 0:
            return True
    return False


def worktree_is_dirty(worktree_path: Path) -> bool:
    result = run_command(
        ["git", "-C", str(worktree_path), "status", "--porcelain"],
        capture=True,
    )
    return bool(result.stdout.strip())


def check_prerequisites() -> list[str]:
    """Check that required tools are on PATH. Returns list of errors."""
    errors: list[str] = []
    for tool in ("git", "tmux", "bd"):
        result = run_command(["which", tool], capture=True)
        if result.returncode != 0:
            errors.append(f"Required tool not found: {tool}")

    return errors


# ──────────────────────────────────────────────
# Beads helpers
# ──────────────────────────────────────────────


class BeadTask(NamedTuple):
    """Minimal representation of a beads task for prompt building."""

    id: str
    title: str
    description: str
    status: str
    dependencies: list[str]


def bd_show_json(task_id: str) -> dict[str, Any] | None:
    """Run `bd show <id> --json` and return parsed JSON, or None on failure."""
    result = run_command(["bd", "show", task_id, "--json"], capture=True)
    if result.returncode != 0:
        return None
    try:
        data = json.loads(result.stdout)
        # bd show returns a list with one element
        if isinstance(data, list) and len(data) > 0:
            return data[0]
        return data
    except json.JSONDecodeError:
        return None


URD_LABEL = "aura:user:reqs"
URD_TITLE_PREFIX = "[aura:user:reqs]"


def _is_urd(task: dict[str, Any]) -> bool:
    """Check if a task is a User Requirements Document by label or title convention."""
    labels = task.get("labels") or []
    if URD_LABEL in labels:
        return True
    title = task.get("title", "")
    if title.startswith(URD_TITLE_PREFIX):
        return True
    return False


def discover_urd(epic_id: str, explicit_urd: str | None) -> str | None:
    """Discover the User Requirements Document task for an epic.

    If explicit_urd is given, use it directly.
    Otherwise, walk the epic's dependency chain (2 levels deep)
    looking for a task with the 'aura:user:reqs' label or title prefix.
    """
    if explicit_urd:
        return explicit_urd

    epic = bd_show_json(epic_id)
    if epic is None:
        return None

    # Search through dependencies (things this epic depends on)
    # and their relatives (transitive, one level deep)
    visited: set[str] = set()
    to_check: list[str] = []

    for dep in epic.get("dependencies", []):
        if isinstance(dep, dict) and "id" in dep:
            if _is_urd(dep):
                return dep["id"]
            to_check.append(dep["id"])
            visited.add(dep["id"])

    # Check one more level: dependents and dependencies of our deps
    for dep_id in to_check:
        dep_data = bd_show_json(dep_id)
        if dep_data is None:
            continue
        for related in dep_data.get("dependents", []):
            if isinstance(related, dict) and "id" in related:
                rid = related["id"]
                if rid in visited or rid == epic_id:
                    continue
                visited.add(rid)
                if _is_urd(related):
                    return rid
        for related in dep_data.get("dependencies", []):
            if isinstance(related, dict) and "id" in related:
                rid = related["id"]
                if rid in visited:
                    continue
                visited.add(rid)
                if _is_urd(related):
                    return rid

    return None


def discover_tasks(epic_id: str, explicit_task_ids: list[str] | None) -> list[BeadTask]:
    """Discover tasks for an epic.

    If explicit_task_ids are given, fetch those.
    Otherwise, look at the epic's dependents (children).
    """
    if explicit_task_ids:
        task_ids = explicit_task_ids
    else:
        # Get the epic and extract its dependents
        epic = bd_show_json(epic_id)
        if epic is None:
            print(f"Warning: Could not fetch epic {epic_id} from beads", file=sys.stderr)
            return []
        dependents = epic.get("dependents", [])
        task_ids = [d["id"] for d in dependents if isinstance(d, dict) and "id" in d]

    tasks: list[BeadTask] = []
    for tid in task_ids:
        data = bd_show_json(tid)
        if data is None:
            print(f"Warning: Could not fetch task {tid}", file=sys.stderr)
            continue
        deps = data.get("dependencies", [])
        dep_ids = [d["id"] for d in deps if isinstance(d, dict) and "id" in d]
        tasks.append(
            BeadTask(
                id=data["id"],
                title=data.get("title", ""),
                description=data.get("description", ""),
                status=data.get("status", "unknown"),
                dependencies=dep_ids,
            )
        )
    return tasks


# ──────────────────────────────────────────────
# Prompt template
# ──────────────────────────────────────────────

PROMPT_TEMPLATE = """\
You are implementing Epic {epic_id}: "{epic_title}"
{urd_section}
## Context Discovery

Before starting, gather full context on the epic and each task using beads:

```bash
# Epic overview (description, dependencies, dependents)
bd show {epic_id}
{urd_show_command}
# Individual task details (description, acceptance criteria, design)
{task_show_commands}
```

## Tasks to Implement

{task_table}

## Instructions

Use Agent Teams (TeamCreate) to coordinate implementation of these tasks.

### Task Assignment
- When assigning a task to a worker, register ownership in beads:
  `bd update <task-id> --assignee "<worker-agent-name>"`
- Then track progress: `bd update <task-id> --status=in_progress` when starting, `bd close <task-id>` when done

### Worker Guidelines
- Create worker agents for each task
- Each worker MUST create and work in its own worktree:
  `git worktree add worktree/agent/<task-id> -b agent/<task-id> {epic_branch}`
  The worker's working directory should be `worktree/agent/<task-id>`
- Workers should run `bd show <their-task-id>` to get full requirements before starting
- Run `npm run typecheck && npm run test` before completing each task
- Use `git agent-commit` for commits (not `git commit`)
- Follow the constraints in CLAUDE.md and CONSTRAINTS.md
- When a task is done, merge the agent branch back into `{epic_branch}`
{urd_instructions}"""


def build_task_table(tasks: list[BeadTask]) -> str:
    """Build a compact markdown table of tasks."""
    lines = [
        "| ID | Title | Status | Dependencies |",
        "|----|-------|--------|--------------|",
    ]
    for t in tasks:
        deps = ", ".join(t.dependencies) if t.dependencies else "-"
        lines.append(f"| {t.id} | {t.title} | {t.status} | {deps} |")
    return "\n".join(lines)


def build_prompt(
    epic_id: str,
    epic_data: dict[str, Any],
    tasks: list[BeadTask],
    urd_id: str | None,
) -> str:
    task_show_commands = "\n".join(f"bd show {t.id}" for t in tasks)
    task_table = build_task_table(tasks)

    if urd_id:
        urd_section = f"\n**User Requirements Document:** `{urd_id}` — ALL requirements must be met and validated.\n"
        urd_show_command = f"\n# User Requirements Document (MUST satisfy all requirements)\nbd show {urd_id}\n"
        urd_instructions = (
            "\n### Requirements Validation\n"
            f"- The User Requirements Document is `{urd_id}` — run `bd show {urd_id}` to read it\n"
            "- Before claiming completion, verify EVERY requirement in the URD is met\n"
            "- Each worker must check their task's output against the relevant URD requirements\n"
        )
    else:
        urd_section = (
            "\n**User Requirements Document:** Not yet identified — you MUST locate it before starting work.\n"
        )
        urd_show_command = (
            "\n# Find the User Requirements Document\n"
            "# Search beads for URD tasks (by label or title convention):\n"
            'bd list --title-contains "user:reqs" --limit 10\n'
            'bd list --label-any "aura:user:reqs" --limit 10\n'
            "# Also check docs/ for requirement markdown files:\n"
            "# ls docs/urd-*.md\n"
        )
        urd_instructions = (
            "\n### Requirements Validation\n"
            "- The User Requirements Document was NOT automatically found\n"
            "- Before starting implementation, locate the URD using the discovery commands above\n"
            "- Check beads tasks AND `docs/urd-*.md` files for requirements related to this epic\n"
            "- ALL requirements in the URD must be met and validated before claiming completion\n"
            "- Each worker must check their task's output against the relevant URD requirements\n"
        )

    return PROMPT_TEMPLATE.format(
        epic_id=epic_id,
        epic_title=epic_data.get("title", ""),
        epic_branch=f"epic/{epic_id}",
        task_show_commands=task_show_commands,
        task_table=task_table,
        urd_section=urd_section,
        urd_show_command=urd_show_command,
        urd_instructions=urd_instructions,
    )


# ──────────────────────────────────────────────
# Subcommands
# ──────────────────────────────────────────────


def cmd_start(args: argparse.Namespace) -> int:
    """Create worktree, gather tasks, launch Claude."""
    git_root = get_git_root()
    if git_root is None:
        print("Error: Not inside a git repository", file=sys.stderr)
        return 1

    epic_id: str = args.epic
    role: str = args.role
    model: str = args.model
    skill: str | None = args.skill
    dry_run: bool = args.dry_run
    worktree_dir = Path(args.worktree_dir)
    explicit_tasks: list[str] | None = args.task_ids if args.task_ids else None
    explicit_urd: str | None = args.urd

    epic_branch = f"epic/{epic_id}"
    worktree_path = git_root / worktree_dir / epic_id

    sessions = SessionsFile(git_root)

    # Check for existing active session
    existing = sessions.find_session(epic_id)
    if existing and check_tmux_session_exists(existing.tmux_session):
        print(f"Epic {epic_id} already has an active session: {existing.tmux_session}")
        print(f"  Attach with: aura-swarm attach {epic_id}")
        return 1

    # ── Step 1: Epic branch + worktree setup ──

    if worktree_path.exists():
        print(f"Warning: Worktree already exists at {worktree_path}, reusing.")
        if dry_run:
            print(f"  [dry-run] Would reuse worktree at {worktree_path}")
    else:
        if branch_exists(epic_branch):
            git_worktree_cmd = [
                "git", "worktree", "add", str(worktree_path), epic_branch,
            ]
        else:
            git_worktree_cmd = [
                "git", "worktree", "add", str(worktree_path), "-b", epic_branch,
            ]

        if dry_run:
            print(f"  [dry-run] Would run: {' '.join(git_worktree_cmd)}")
        else:
            print(f"Creating worktree at {worktree_path} on branch {epic_branch}...")
            result = run_command(git_worktree_cmd, capture=True)
            if result.returncode != 0:
                print(f"Error creating worktree: {result.stderr.strip()}", file=sys.stderr)
                return 1
            print(f"  Created: {worktree_path}")

    # ── Step 2: Task discovery ──

    print("Discovering tasks...")
    epic_data = bd_show_json(epic_id)
    if epic_data is None:
        print(f"Error: Could not fetch epic {epic_id} from beads", file=sys.stderr)
        return 1

    tasks = discover_tasks(epic_id, explicit_tasks)
    if not tasks:
        print(f"No tasks found for epic {epic_id}.")
        print("  Provide task IDs explicitly: aura-swarm start --epic {epic_id} task-1 task-2")
        return 0

    print(f"  Found {len(tasks)} task(s):")
    for t in tasks:
        print(f"    {t.id}: {t.title} [{t.status}]")

    # ── Step 2b: URD discovery ──

    urd_id = discover_urd(epic_id, explicit_urd)
    if urd_id:
        print(f"  URD: {urd_id}")
    else:
        print("  No URD found (specify with --urd <id> if needed)")

    # ── Step 3: Build prompt ──

    prompt = build_prompt(epic_id, epic_data, tasks, urd_id)

    if dry_run:
        print()
        print("Generated prompt:")
        print("-" * 60)
        # Truncate for display
        if len(prompt) > 3000:
            print(prompt[:3000])
            print(f"... ({len(prompt)} chars total, truncated)")
        else:
            print(prompt)
        print("-" * 60)
        print()
        print("Dry run complete. No sessions created.")
        return 0

    # ── Step 4: Load role instructions and launch tmux session directly ──

    role_instructions, instructions_path = get_role_instructions(role, worktree_path)
    if role_instructions is None:
        print(
            f"Error: Role file not found: .claude/commands/aura:{role}.md",
            file=sys.stderr,
        )
        print(f"  Looked in: {worktree_path}/.claude/commands/", file=sys.stderr)
        print(f"  Looked in: {Path.home()}/.claude/commands/", file=sys.stderr)
        return 1

    launched_session = generate_tmux_session_name(epic_id)

    print(f"\nLaunching Claude ({model}, role={role})...")
    print(f"  Role instructions: {instructions_path}")

    result = launch_tmux_session(
        session_name=launched_session,
        working_dir=worktree_path,
        role_instructions=role_instructions,
        prompt=prompt,
        model=model,
    )
    if not result.success:
        print(f"Error launching tmux session: {result.error}", file=sys.stderr)
        return 1

    print(f"  Started: {launched_session}")

    # ── Step 5: Record session ──

    entry = SessionEntry(
        epic_id=epic_id,
        epic_branch=epic_branch,
        worktree=str(worktree_path),
        tmux_session=launched_session,
        started_at=datetime.now(timezone.utc).isoformat(),
        model=model,
        task_ids=[t.id for t in tasks],
    )
    sessions.add_session(entry)

    # ── Step 6: Summary ──

    print()
    print(f"Swarm session started for epic {epic_id}")
    print(f"  tmux session: {launched_session}")
    print(f"  worktree:     {worktree_path}")
    print(f"  branch:       {epic_branch}")
    print(f"  tasks:        {len(tasks)}")
    print()
    print(f"  Attach: aura-swarm attach {epic_id}")
    print(f"          tmux attach -t {launched_session}")
    print(f"  Stop:   aura-swarm stop {epic_id}")
    print(f"          tmux kill-session -t {launched_session}")
    return 0


def cmd_status(args: argparse.Namespace) -> int:
    """Print table of active swarm sessions."""
    git_root = get_git_root()
    if git_root is None:
        print("Error: Not inside a git repository", file=sys.stderr)
        return 1

    sessions = SessionsFile(git_root)
    entries = sessions.get_sessions()

    if not entries:
        print("No active swarm sessions.")
        return 0

    # Header
    print(f"{'epic-id':<16} {'tmux session':<28} {'alive?':<8} {'worktree':<30} {'branch':<24} {'# tasks':<8}")
    print("-" * 114)

    for e in entries:
        alive = "yes" if check_tmux_session_exists(e.tmux_session) else "no"
        # Shorten worktree path for display
        wt = e.worktree
        if len(wt) > 28:
            wt = "..." + wt[-25:]
        print(
            f"{e.epic_id:<16} {e.tmux_session:<28} {alive:<8} {wt:<30} {e.epic_branch:<24} {len(e.task_ids):<8}"
        )
    return 0


def cmd_attach(args: argparse.Namespace) -> int:
    """Attach to an epic's tmux session."""
    git_root = get_git_root()
    if git_root is None:
        print("Error: Not inside a git repository", file=sys.stderr)
        return 1

    sessions = SessionsFile(git_root)
    entry = sessions.find_session(args.epic_id)

    if entry is None:
        print(f"No session found for epic {args.epic_id}", file=sys.stderr)
        print("  Run `aura-swarm status` to see active sessions.", file=sys.stderr)
        return 1

    if not check_tmux_session_exists(entry.tmux_session):
        print(f"tmux session '{entry.tmux_session}' is no longer alive.", file=sys.stderr)
        print(f"  Run `aura-swarm stop {args.epic_id}` to clean up.", file=sys.stderr)
        return 1

    print(f"Attaching to {entry.tmux_session}...")
    os.execvp("tmux", ["tmux", "attach", "-t", entry.tmux_session])
    # execvp replaces this process; the line below only runs on error
    return 1


def cmd_stop(args: argparse.Namespace) -> int:
    """Kill tmux session, leave worktree intact."""
    git_root = get_git_root()
    if git_root is None:
        print("Error: Not inside a git repository", file=sys.stderr)
        return 1

    sessions = SessionsFile(git_root)
    entry = sessions.find_session(args.epic_id)

    if entry is None:
        print(f"No session found for epic {args.epic_id}", file=sys.stderr)
        return 1

    if check_tmux_session_exists(entry.tmux_session):
        if args.dry_run:
            print(f"  [dry-run] Would kill tmux session: {entry.tmux_session}")
        else:
            run_command(["tmux", "kill-session", "-t", entry.tmux_session], capture=True)
            print(f"Killed tmux session: {entry.tmux_session}")
    else:
        print(f"tmux session '{entry.tmux_session}' was already dead.")

    if not args.dry_run:
        sessions.remove_session(args.epic_id)
        print(f"Removed session record for {args.epic_id}")
        print(f"  Worktree preserved at: {entry.worktree}")

    return 0


def cmd_merge(args: argparse.Namespace) -> int:
    """Merge epic branch back to main."""
    git_root = get_git_root()
    if git_root is None:
        print("Error: Not inside a git repository", file=sys.stderr)
        return 1

    epic_id: str = args.epic_id
    epic_branch = f"epic/{epic_id}"
    dry_run: bool = args.dry_run

    # Find worktree to check cleanliness
    sessions = SessionsFile(git_root)
    entry = sessions.find_session(epic_id)
    if entry:
        wt_path = Path(entry.worktree)
        if wt_path.exists() and worktree_is_dirty(wt_path):
            print(f"Error: Worktree at {wt_path} has uncommitted changes.", file=sys.stderr)
            print("  Commit or stash changes before merging.", file=sys.stderr)
            return 1

    if not branch_exists(epic_branch, cwd=git_root):
        print(f"Error: Branch {epic_branch} does not exist.", file=sys.stderr)
        return 1

    if dry_run:
        print(f"  [dry-run] Would merge {epic_branch} into current branch with --no-ff")
        return 0

    print(f"Merging {epic_branch} into current branch...")
    result = run_command(
        ["git", "merge", epic_branch, "--no-ff", "-m", f"Merge epic/{epic_id}"],
        capture=True,
        cwd=git_root,
    )
    if result.returncode != 0:
        # Attempt to detect conflicts
        stderr = result.stderr.strip() if result.stderr else ""
        stdout = result.stdout.strip() if result.stdout else ""

        print(f"Merge failed.", file=sys.stderr)
        if "CONFLICT" in stdout or "CONFLICT" in stderr:
            print("Conflicts detected. Aborting merge...", file=sys.stderr)
            run_command(["git", "merge", "--abort"], capture=True, cwd=git_root)

            # Show conflicting files
            if stdout:
                print(stdout, file=sys.stderr)
            print("\nResolve conflicts manually, then retry.", file=sys.stderr)
        else:
            if stderr:
                print(stderr, file=sys.stderr)
            if stdout:
                print(stdout, file=sys.stderr)
        return 1

    print(f"Successfully merged {epic_branch}")
    if result.stdout.strip():
        print(result.stdout.strip())
    return 0


def cmd_review(args: argparse.Namespace) -> int:
    """Generate a review document for a completed epic."""
    git_root = get_git_root()
    if git_root is None:
        print("Error: Not inside a git repository", file=sys.stderr)
        return 1

    epic_id: str = args.epic
    epic_branch = f"epic/{epic_id}"
    dry_run: bool = args.dry_run

    if not branch_exists(epic_branch, cwd=git_root):
        print(f"Error: Branch {epic_branch} does not exist.", file=sys.stderr)
        return 1

    # Collect epic data
    epic_data = bd_show_json(epic_id)
    if epic_data is None:
        print(f"Error: Could not fetch epic {epic_id} from beads", file=sys.stderr)
        return 1

    tasks = discover_tasks(epic_id, None)

    # Get diff stats
    diff_stat_result = run_command(
        ["git", "diff", "--stat", f"main...{epic_branch}"],
        capture=True,
        cwd=git_root,
    )
    diff_stat = diff_stat_result.stdout.strip() if diff_stat_result.returncode == 0 else "N/A"

    # Build review document
    doc_lines = [
        f"# Review: Epic {epic_id}",
        f"",
        f"**Title:** {epic_data.get('title', '')}",
        f"**Branch:** {epic_branch}",
        f"**Generated:** {datetime.now(timezone.utc).isoformat()}",
        f"",
        f"## Epic Description",
        f"",
        epic_data.get("description", ""),
        f"",
        f"## Task Breakdown",
        f"",
    ]

    for t in tasks:
        doc_lines.append(f"### {t.id}: {t.title}")
        doc_lines.append(f"**Status:** {t.status}")
        if t.dependencies:
            doc_lines.append(f"**Dependencies:** {', '.join(t.dependencies)}")
        doc_lines.append(f"")

    doc_lines.extend([
        f"## Diff Summary",
        f"",
        f"```",
        diff_stat,
        f"```",
        f"",
        f"## Review Checklist",
        f"",
        f"- [ ] All tasks completed",
        f"- [ ] Tests pass (`npm run test`)",
        f"- [ ] Type checking passes (`npm run typecheck`)",
        f"- [ ] No security issues introduced",
        f"- [ ] Code follows project conventions",
        f"- [ ] Documentation updated if needed",
        f"",
    ])

    doc_content = "\n".join(doc_lines)
    review_path = git_root / "docs" / f"review-{epic_id}.md"

    if dry_run:
        print(f"  [dry-run] Would write review to {review_path}")
        print(f"  [dry-run] Would create beads task: [REVIEW] Epic {epic_id}")
        print()
        print("Preview:")
        print("-" * 60)
        print(doc_content[:2000])
        if len(doc_content) > 2000:
            print(f"... ({len(doc_content)} chars total)")
        print("-" * 60)
        return 0

    # Write review doc
    review_path.parent.mkdir(parents=True, exist_ok=True)
    review_path.write_text(doc_content)
    print(f"Wrote review document: {review_path}")

    # Create beads task for the review
    create_result = run_command(
        ["bd", "create", f"--title=[REVIEW] Epic {epic_id}", "--type=task", "--priority=1"],
        capture=True,
    )
    if create_result.returncode == 0:
        # Try to extract the created task ID from output
        output = create_result.stdout.strip()
        print(f"Created review task: {output}")
    else:
        print(f"Warning: Could not create beads review task", file=sys.stderr)

    return 0


def cmd_cleanup(args: argparse.Namespace) -> int:
    """Remove worktrees and branches."""
    git_root = get_git_root()
    if git_root is None:
        print("Error: Not inside a git repository", file=sys.stderr)
        return 1

    sessions = SessionsFile(git_root)
    dry_run: bool = args.dry_run
    force: bool = args.force

    # Determine which epics to clean up
    if args.epic_id:
        targets = [args.epic_id]
    elif args.done:
        # Find sessions whose epic branch is merged into main
        targets = []
        for entry in sessions.get_sessions():
            if branch_merged_into_main(entry.epic_branch, cwd=git_root):
                targets.append(entry.epic_id)
        if not targets:
            print("No merged epic branches found to clean up.")
            return 0
        print(f"Found {len(targets)} merged epic(s) to clean up:")
        for t in targets:
            print(f"  - {t}")
    elif args.all:
        entries = sessions.get_sessions()
        if not entries:
            print("No sessions to clean up.")
            return 0

        print(f"The following {len(entries)} worktree(s) will be removed:")
        for e in entries:
            dirty = " (DIRTY)" if Path(e.worktree).exists() and worktree_is_dirty(Path(e.worktree)) else ""
            alive = " (tmux alive)" if check_tmux_session_exists(e.tmux_session) else ""
            print(f"  - {e.epic_id}: {e.worktree}{dirty}{alive}")

        if not dry_run:
            confirm = input("\nType 'yes' to confirm cleanup: ")
            if confirm.strip().lower() != "yes":
                print("Aborted.")
                return 0

        targets = [e.epic_id for e in entries]
    else:
        print("Error: Provide an epic-id, --done, or --all", file=sys.stderr)
        return 1

    errors = 0
    for epic_id in targets:
        entry = sessions.find_session(epic_id)
        worktree_path = Path(entry.worktree) if entry else git_root / DEFAULT_WORKTREE_DIR / epic_id
        epic_branch = f"epic/{epic_id}"

        # Check dirty state
        if worktree_path.exists() and worktree_is_dirty(worktree_path):
            if not force:
                print(f"  Skipping {epic_id}: worktree is dirty (use --force to override)", file=sys.stderr)
                errors += 1
                continue

        # Kill tmux if alive
        if entry and check_tmux_session_exists(entry.tmux_session):
            if dry_run:
                print(f"  [dry-run] Would kill tmux: {entry.tmux_session}")
            else:
                run_command(["tmux", "kill-session", "-t", entry.tmux_session], capture=True)
                print(f"  Killed tmux: {entry.tmux_session}")

        # Remove worktree
        if worktree_path.exists():
            if dry_run:
                print(f"  [dry-run] Would remove worktree: {worktree_path}")
            else:
                wt_cmd = ["git", "worktree", "remove", str(worktree_path)]
                if force:
                    wt_cmd.append("--force")
                result = run_command(wt_cmd, capture=True, cwd=git_root)
                if result.returncode != 0:
                    print(f"  Error removing worktree {worktree_path}: {result.stderr.strip()}", file=sys.stderr)
                    errors += 1
                    continue
                print(f"  Removed worktree: {worktree_path}")

        # Delete branch
        if branch_exists(epic_branch, cwd=git_root):
            if dry_run:
                print(f"  [dry-run] Would delete branch: {epic_branch}")
            else:
                # Use -d (safe delete) unless force
                flag = "-D" if force else "-d"
                result = run_command(
                    ["git", "branch", flag, epic_branch],
                    capture=True,
                    cwd=git_root,
                )
                if result.returncode != 0:
                    print(f"  Error deleting branch {epic_branch}: {result.stderr.strip()}", file=sys.stderr)
                    errors += 1
                else:
                    print(f"  Deleted branch: {epic_branch}")

        # Update sessions.json
        if not dry_run:
            sessions.remove_session(epic_id)

    if dry_run:
        print("\nDry run complete. No changes made.")
    elif errors:
        print(f"\nCleanup completed with {errors} error(s).")
    else:
        print("\nCleanup complete.")

    return errors > 0


# ──────────────────────────────────────────────
# Argument parser
# ──────────────────────────────────────────────


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="aura-swarm",
        description="Automated worktree agent workflow — launch Claude swarms for epics",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=textwrap.dedent("""\
            Examples:
              aura-swarm start --epic aura-dyu                  # Launch with default settings
              aura-swarm start --epic aura-dyu --model opus     # Use opus model
              aura-swarm start --epic aura-dyu --dry-run        # Preview without launching
              aura-swarm start --epic aura-dyu task-1 task-2    # Explicit task list
              aura-swarm status                                 # Show active sessions
              aura-swarm attach aura-dyu                        # Attach to tmux session
              aura-swarm stop aura-dyu                          # Kill session, keep worktree
              aura-swarm merge aura-dyu                         # Merge epic to main
              aura-swarm review --epic aura-dyu                 # Generate review doc
              aura-swarm cleanup aura-dyu                       # Remove worktree + branch
              aura-swarm cleanup --done                         # Clean merged epics
              aura-swarm cleanup --all                          # Interactive cleanup of all
        """),
    )

    # Shared flags — defined on a parent parser and inherited by every subcommand.
    # Combined with _hoist_global_flags() so they work in any argv position.
    shared = argparse.ArgumentParser(add_help=False)
    shared.add_argument(
        "--dry-run",
        action="store_true",
        default=False,
        help="Show what would be done without executing",
    )
    shared.add_argument(
        "--worktree-dir",
        default=DEFAULT_WORKTREE_DIR,
        help=f"Override worktree root directory (default: {DEFAULT_WORKTREE_DIR}/)",
    )

    subparsers = parser.add_subparsers(dest="command", required=True)

    # ── start ──
    start_p = subparsers.add_parser(
        "start",
        parents=[shared],
        help="Create worktree, gather tasks, launch Claude swarm",
    )
    start_p.add_argument("--epic", required=True, help="Epic beads ID")
    start_p.add_argument(
        "--role",
        default=DEFAULT_ROLE,
        choices=sorted(VALID_ROLES),
        help=f"Agent role (default: {DEFAULT_ROLE})",
    )
    start_p.add_argument(
        "--model",
        default=DEFAULT_MODEL,
        choices=sorted(VALID_MODELS),
        help=f"Model to use (default: {DEFAULT_MODEL})",
    )
    start_p.add_argument("--skill", help="Skill to invoke at start")
    start_p.add_argument(
        "--urd",
        help="User Requirements Document beads ID (auto-discovered if not set)",
    )
    start_p.add_argument(
        "task_ids",
        nargs="*",
        default=None,
        help="Explicit task IDs (default: discover from epic dependents)",
    )

    # ── status ──
    subparsers.add_parser("status", parents=[shared], help="Show active swarm sessions")

    # ── attach ──
    attach_p = subparsers.add_parser("attach", parents=[shared], help="Attach to an epic's tmux session")
    attach_p.add_argument("epic_id", help="Epic beads ID")

    # ── stop ──
    stop_p = subparsers.add_parser("stop", parents=[shared], help="Kill tmux session, preserve worktree")
    stop_p.add_argument("epic_id", help="Epic beads ID")

    # ── merge ──
    merge_p = subparsers.add_parser("merge", parents=[shared], help="Merge epic branch back to main")
    merge_p.add_argument("epic_id", help="Epic beads ID")

    # ── review ──
    review_p = subparsers.add_parser("review", parents=[shared], help="Generate review document for an epic")
    review_p.add_argument("--epic", required=True, help="Epic beads ID")

    # ── cleanup ──
    cleanup_p = subparsers.add_parser("cleanup", parents=[shared], help="Remove worktrees and branches")
    cleanup_target = cleanup_p.add_mutually_exclusive_group(required=True)
    cleanup_target.add_argument("epic_id", nargs="?", default=None, help="Specific epic ID")
    cleanup_target.add_argument(
        "--done",
        action="store_true",
        help="Remove worktrees for epic branches already merged to main",
    )
    cleanup_target.add_argument(
        "--all",
        action="store_true",
        help="Remove all worktrees (interactive confirmation required)",
    )
    cleanup_p.add_argument(
        "--force",
        action="store_true",
        help="Force removal even if worktree is dirty",
    )

    return parser


# ──────────────────────────────────────────────
# Argv pre-processing
# ──────────────────────────────────────────────

_SUBCOMMANDS = frozenset(["start", "status", "attach", "stop", "merge", "review", "cleanup"])

# Flags that should work in any position (before or after the subcommand).
# Listed as (flag, has_value) tuples.
_GLOBAL_FLAGS = [
    ("--dry-run", False),
    ("--worktree-dir", True),
]


def _hoist_global_flags(argv: list[str]) -> list[str]:
    """Move global flags to right after the subcommand so argparse sees them.

    This allows ``aura-swarm --dry-run start ...`` and
    ``aura-swarm start --dry-run ...`` to behave identically.
    """
    hoisted: list[str] = []
    remaining: list[str] = []
    i = 0
    while i < len(argv):
        arg = argv[i]
        matched = False
        for flag, has_value in _GLOBAL_FLAGS:
            if arg == flag:
                hoisted.append(arg)
                if has_value and i + 1 < len(argv):
                    i += 1
                    hoisted.append(argv[i])
                matched = True
                break
            if has_value and arg.startswith(flag + "="):
                hoisted.append(arg)
                matched = True
                break
        if not matched:
            remaining.append(arg)
        i += 1

    # Insert hoisted flags right after the first subcommand token
    result: list[str] = []
    inserted = False
    for arg in remaining:
        result.append(arg)
        if not inserted and arg in _SUBCOMMANDS:
            result.extend(hoisted)
            inserted = True
    if not inserted:
        # No subcommand found (e.g. --help) — append anyway
        result.extend(hoisted)
    return result


# ──────────────────────────────────────────────
# Main
# ──────────────────────────────────────────────


def main() -> int:
    signal.signal(signal.SIGINT, signal_handler)

    parser = build_parser()
    args = parser.parse_args(_hoist_global_flags(sys.argv[1:]))

    # Check prerequisites
    prereq_errors = check_prerequisites()
    if prereq_errors:
        for err in prereq_errors:
            print(f"Error: {err}", file=sys.stderr)
        return 1

    command = args.command
    dispatch = {
        "start": cmd_start,
        "status": cmd_status,
        "attach": cmd_attach,
        "stop": cmd_stop,
        "merge": cmd_merge,
        "review": cmd_review,
        "cleanup": cmd_cleanup,
    }

    handler = dispatch.get(command)
    if handler is None:
        parser.print_help()
        return 1

    return handler(args)


if __name__ == "__main__":
    sys.exit(main())
