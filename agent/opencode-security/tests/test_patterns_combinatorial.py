"""Combinatorial tests for pattern matching using fixtures.

These tests use a component-based fixture system to generate comprehensive
test coverage without manually listing hundreds of test cases.

The fixture (tests/fixtures/patterns.yaml) defines:
1. Path prefixes (where files can live)
2. Denied pattern components (organized by category)
3. Allowed pattern components (trusted patterns)
4. Negative cases (edge cases that should NOT match)

Test cases are generated by combining these components, providing broad coverage
of the pattern matching logic.
"""

from pathlib import Path

import pytest

from opencode_security.patterns import match_pattern
from .fixtures.pattern_fixture import PatternFixture


@pytest.fixture
def fixture():
    """Load pattern fixture from YAML file."""
    fixture_path = Path(__file__).parent / "fixtures" / "patterns.yaml"
    return PatternFixture(str(fixture_path))


class TestDeniedPatternsCombinatorial:
    """Test all denied patterns against combinatorial test cases."""

    def test_denied_patterns_generated_cases(self, fixture):
        """Test that denied patterns match their generated test cases.

        This test validates that the fixture can generate test cases and that
        the pattern matcher behaves correctly for denied patterns.
        """
        test_cases = list(fixture.generate_denied_test_cases())
        assert len(test_cases) > 0, "Should generate denied test cases"

        # Sample of test cases to validate fixture structure
        matched = 0
        for test_case in test_cases[:10]:  # Test first 10
            # Verify fixture structure
            assert test_case.path
            assert test_case.pattern
            assert test_case.expected_decision == "deny"
            assert test_case.level in [
                "FILE_EXTENSION",
                "FILE_NAME",
                "DIR_GLOB",
                "SECURITY_DIRECTORY",
            ]

            # Test that pattern matches the path
            # (Note: this is a basic check; actual matching depends on match_pattern logic)
            if test_case.level == "FILE_EXTENSION":
                # Extension patterns should match files with that extension
                result = match_pattern(test_case.pattern, test_case.path)
                if result:
                    matched += 1

        assert matched > 0, "At least some denied patterns should match their test cases"

    @pytest.mark.parametrize(
        "test_case",
        [
            pytest.param(tc, id=f"{tc.category}:{tc.path}")
            for tc in PatternFixture(
                Path(__file__).parent / "fixtures" / "patterns.yaml"
            ).generate_denied_test_cases()
        ],
    )
    def test_each_denied_pattern(self, test_case):
        """Parametrized test: verify each denied pattern matches its test case."""
        # This test is skipped in normal runs due to performance
        # but useful for debugging specific patterns
        if test_case.level == "FILE_EXTENSION":
            # File extensions should match by name
            assert match_pattern(test_case.pattern, test_case.path), (
                f"Pattern '{test_case.pattern}' should match '{test_case.path}' "
                f"({test_case.description})"
            )


class TestAllowedPatternsCombinatorial:
    """Test all allowed patterns against combinatorial test cases."""

    def test_allowed_patterns_generated_cases(self, fixture):
        """Test that allowed patterns match their generated test cases."""
        test_cases = list(fixture.generate_allowed_test_cases())
        assert len(test_cases) > 0, "Should generate allowed test cases"

        # Verify structure
        for test_case in test_cases[:10]:
            assert test_case.path
            assert test_case.pattern
            assert test_case.expected_decision == "allow"

    @pytest.mark.parametrize(
        "test_case",
        [
            pytest.param(tc, id=f"{tc.category}:{tc.path}")
            for tc in PatternFixture(
                Path(__file__).parent / "fixtures" / "patterns.yaml"
            ).generate_allowed_test_cases()
        ],
    )
    def test_each_allowed_pattern(self, test_case):
        """Parametrized test: verify each allowed pattern matches its test case."""
        if test_case.level == "FILE_EXTENSION":
            assert match_pattern(test_case.pattern, test_case.path), (
                f"Pattern '{test_case.pattern}' should match '{test_case.path}' "
                f"({test_case.description})"
            )


class TestNegativeCasesCombinatorial:
    """Test negative cases (should NOT match denied patterns)."""

    def test_negative_cases_structure(self, fixture):
        """Validate that negative cases are properly defined."""
        test_cases = list(fixture.generate_negative_test_cases())
        assert len(test_cases) > 0, "Should have negative test cases"

        for test_case in test_cases:
            assert test_case.path
            assert test_case.category
            # Negative cases should default to allow (safe by default)
            assert test_case.expected_decision in ["allow", "pass"]

    def test_secret_word_variants_not_matched_as_directory(self, fixture):
        """Validate that words containing 'secret' but not as directory are safe."""
        negative_cases = list(fixture.generate_negative_test_cases())

        # Find secret word variants
        secret_variants = [
            tc for tc in negative_cases if tc.category == "secret_word_variants"
        ]
        assert (
            len(secret_variants) > 0
        ), "Should have secret word variant negative cases"

        for test_case in secret_variants:
            # These should NOT match **/secrets/** pattern
            result = match_pattern("**/secrets/**", test_case.path)
            assert not result, (
                f"Path '{test_case.path}' should NOT match '**/secrets/**' pattern"
            )


class TestFixtureLoadingAndGeneration:
    """Test the fixture loading and case generation mechanisms."""

    def test_fixture_loads_successfully(self, fixture):
        """Verify fixture loads and has expected sections."""
        assert fixture.path_prefixes
        assert fixture.denied_patterns
        assert fixture.allowed_patterns
        assert fixture.negative_cases

    def test_path_prefixes_are_valid(self, fixture):
        """Verify path prefixes are well-formed."""
        for prefix in fixture.path_prefixes:
            # Allow: absolute (/), home-relative (~), relative (., ./), or bare ("")
            is_valid = (
                prefix.startswith("/")
                or prefix.startswith("~")
                or prefix.startswith(".")
                or prefix == ""  # Bare filename
            )
            assert is_valid, f"Prefix should be absolute, relative, or home-relative: {prefix}"

    def test_denied_patterns_have_required_fields(self, fixture):
        """Verify each denied pattern category has required fields."""
        for category, pattern_def in fixture.denied_patterns.items():
            assert "decision" in pattern_def, f"{category}: missing 'decision'"
            assert pattern_def["decision"] == "deny"
            assert "level" in pattern_def, f"{category}: missing 'level'"
            assert "patterns" in pattern_def, f"{category}: missing 'patterns'"

    def test_allowed_patterns_have_required_fields(self, fixture):
        """Verify each allowed pattern category has required fields."""
        for category, pattern_def in fixture.allowed_patterns.items():
            assert "decision" in pattern_def, f"{category}: missing 'decision'"
            assert pattern_def["decision"] == "allow"
            assert "level" in pattern_def, f"{category}: missing 'level'"
            assert "patterns" in pattern_def, f"{category}: missing 'patterns'"

    def test_case_generation_produces_different_types(self, fixture):
        """Verify that case generation produces different pattern types."""
        all_cases = list(fixture.generate_all_test_cases())
        assert len(all_cases) > 0

        # Should have different levels represented
        levels = {tc.level for tc in all_cases}
        assert "FILE_EXTENSION" in levels
        assert "FILE_NAME" in levels or "DIR_GLOB" in levels or "SECURITY_DIRECTORY" in levels

    def test_denied_and_allowed_cases_separate(self, fixture):
        """Verify denied and allowed cases are properly separated."""
        denied = list(fixture.generate_denied_test_cases())
        allowed = list(fixture.generate_allowed_test_cases())

        assert len(denied) > 0, "Should have denied test cases"
        assert len(allowed) > 0, "Should have allowed test cases"

        # Verify no overlap in decisions
        denied_decisions = {tc.expected_decision for tc in denied}
        allowed_decisions = {tc.expected_decision for tc in allowed}

        assert denied_decisions == {"deny"}
        assert allowed_decisions == {"allow"}


class TestFixtureStatistics:
    """Gather statistics about fixture coverage."""

    def test_fixture_coverage_summary(self, fixture):
        """Print summary statistics about fixture coverage."""
        denied = list(fixture.generate_denied_test_cases())
        allowed = list(fixture.generate_allowed_test_cases())
        negative = list(fixture.generate_negative_test_cases())

        print(f"\nFixture Coverage Summary:")
        print(f"  Denied patterns: {len(denied)} test cases")
        print(f"  Allowed patterns: {len(allowed)} test cases")
        print(f"  Negative cases: {len(negative)} test cases")
        print(f"  Total: {len(denied) + len(allowed) + len(negative)} test cases")

        print(f"\nDenied patterns by level:")
        denied_by_level = {}
        for tc in denied:
            denied_by_level.setdefault(tc.level, 0)
            denied_by_level[tc.level] += 1
        for level, count in sorted(denied_by_level.items()):
            print(f"  {level}: {count}")

        print(f"\nAllowed patterns by level:")
        allowed_by_level = {}
        for tc in allowed:
            allowed_by_level.setdefault(tc.level, 0)
            allowed_by_level[tc.level] += 1
        for level, count in sorted(allowed_by_level.items()):
            print(f"  {level}: {count}")

        # Assert reasonable coverage
        assert len(denied) > 50, "Should have many denied pattern test cases"
        assert len(allowed) > 20, "Should have multiple allowed pattern test cases"
        assert len(negative) > 5, "Should have several negative test cases"
